# 2024-01-29
mainブランチがいつの間にか動作しなくなってしまった（画面が激しくちらつく。libstdc++からlibc++を使うようにしたせい？）。
なので「libc++」ブランチを切って、徐々にlibc++に対応させている途中なのが現状。
mainの方ですでに適用しているCamera.cppなども改めて適用し直したい。

## 方針の転換
遡って順にやっていけばlibc++にも対応できるかと思ったが、原因不明で気まぐれに画面がおかしくなってしまうらしい。
libc++およびclang17以降（c++23）に対応するのは一旦諦め、clang16とlibstdc++でのビルドに戻すことにする。
残念ではあるが、しかしそもそもの動機はclang15以前ではテンプレート周りでバグがあったため、もっと上のバージョンにしようというものであったのだから、clang16でも何ら問題は無いだろう。

## worldをいちいち指定するのが冗長すぎる
あらゆるWorldObjectのコンストラクタでworldを明示しないといけないのは煩わしい。
現状の設計は、親のいないWorldObjectも描画と更新が可能であるという利点を持つ。
しかしそもそも親がいないオブジェクトというのはナンセンスであるし、それが描画できてしまうというのもむしろ混乱を生む。
それよりもあらゆるノードはメモリの所有権も含め管理する親が必ずいるものとしたほうが、デザインとして優れているかもしれない。

## 継承か合成か
WorldObjectやDrawableを継承するのではなく、WorldObjectにユーザ領域として使えるAny型メンバ変数を持たせたり、関数オブジェクト型のメンバ変数drawを持たせるというやり方も考えられる。しかし、以下の理由から継承を用いるのが妥当だと考えている。
- 継承してメンバ変数を追加したほうが、変数名が明確で分かりやすい。
- せっかくC++を使っているのだから
…とここまで書いて思ったが、DrawableおよびUpdateは継承オーバーロードよりもメンバ変数としてラムダ式で指定できたほうが、簡潔で便利かつユーザ領域変数と描画/更新関数の関連を切り離せるため柔軟性があって優れている。
いやさらに言えば、描画関数をメンバ変数ではなくworldに直接登録できるようにし、Draw抽象クラスのコンストラクタ内で自動で登録される、もしくは手動でカスタム関数を登録できるという2種類の方法を用意するのがリッチかもしれない。手動で登録したものは手動で開放する必要があるが。


# 2024-01-31
エラーコード1282(GL_INVALID_OPERATION)が出ていた問題を修正した。
原因は`glVertexAttribPointer()`関数でシェーダへuv属性を送る時、VBOを利用せずに直接static変数へのポインタを渡していることだったようだ。これだと幸か不幸か動作こそしてくれるものの、エラーコードは発行されてしまうらしい。
対策として、応急処置というかより望ましい形に近づけるために`setAttribute`を呼ぶ位置だけ変えておいたものの、肝心のuv座標の値自体はめちゃくちゃな状態となっているため要修正。

これからやること
- line.cppの実行時、プログラムの終了時に "malloc(): unsorted double linked list corrupted" などのメモリ関連のエラーが出る問題を修正していく。おそらくsetIntervalで立てた別スレッドの寿命が長すぎて、main関数側の変数が解放されたあとにアクセスしようとするのが原因。マルチスレッドをそもそもやめてglfwのメインループ内で動作するタイマー機構を作る。
